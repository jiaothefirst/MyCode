package MyRegex;

import java.util.*;

public class ASTMatcher {

    private static Map<String,ASTree> treeMap = new HashMap<>();
    private String str;
    private ASTree regexTree;

    private void setStr( String str) {
        this.str = str;
    }

    public static ASTMatcher compile(String regex){
        ASTree tree =treeMap.get(regex);
        if(tree == null){
            tree =RegexToASTree.regexToTree(regex);
            treeMap.put(regex,tree);
        }
        return new ASTMatcher(tree);
    }

    private ASTMatcher(ASTree regexTree) {
        this.regexTree = regexTree;
    }
    public boolean isMatch(String str){
        setStr(str);
        return readASTree(regexTree,0).size() != 0;
    }

    private List<Status> readASTree(ASTree tree, int i){
        switch (tree.getOperateType()){
            case ASTree.CAT:return catNode(tree,i);
            case ASTree.OR:return orNode(tree,i);
            case ASTree.END:return endNode(i);
            case ASTree.ZERO_TO_MULTI:return zero2MultiNode(tree,i);
            case ASTree.ONE_TO_MULTI:return one2MultiNode(tree,i);
            case ASTree.RANGE:return rangeNode(tree,i);
            case ASTree.UN_FIXED:return fixedNode(tree,i);
            default:return terminatorNode(tree,i);
        }
    }
    private List<Status> catNode(ASTree tree, int i){
        List<ASTree> nodes = tree.getTreeList();
        Set<Status> statuses = new HashSet<>();
        statuses.add(new Status(i));
        for(ASTree node : nodes){
            Set<Status> tempStatus = new HashSet<>();
            for(Status status : statuses){
                List<Status> list = readASTree(node,status.getI());
                tempStatus.addAll(list);
            }
            if(tempStatus.size() == 0){
                return new ArrayList<>();
            }
            statuses = tempStatus;

        }
        return new ArrayList<>(statuses);
    }
    private List<Status> orNode(ASTree tree, int i){
        List<ASTree> nodes = tree.getTreeList();
        List<Status> result = new ArrayList<>();
        for(ASTree node : nodes){
            result.addAll(readASTree(node,i));
        }
        return result;
    }
    private List<Status> zero2MultiNode(ASTree tree,int i){
        Set<Status> statuses = new HashSet<>();
        /**
         * 上一次状态
         */
        Set<Status> lastStatus = new HashSet<>();
        Set<Status> used = new HashSet<>();
        /**
         * * 运算只有一个子node
         */
        ASTree childNode = tree.getTreeList().get(0);
        int j=0;
        while (j < Integer.MAX_VALUE){
            statuses.addAll(lastStatus);
            if(j == 0){
                //什么都不做
                Status status = new Status(i);
                lastStatus.add(status);
                statuses.add(status);
            } else {
                Set<Status> curStatus = new HashSet<>();
                for(Status status : lastStatus){
                    //used记录已经访问的状态，防止循环进入
                    if(!used.contains(status)){
                        used.add(status);
                        /**
                         * 容易出错的地方  调用函数用到的i 应该是 status的i
                         */
                        List<Status> list = readASTree(childNode,status.getI());
                        curStatus.addAll(list);
                    }
                }
                /**
                 * 判断出现了多少个新状态
                 */
                if(newStatusSize(used,curStatus) == 0){
                    break;
                }
                lastStatus = curStatus;
            }
            j++;
        }
        return new ArrayList<>(statuses);
    }

    private int newStatusSize(Set<Status> usedStatus,Set<Status> cur){
        int size = 0;
        for(Status s : cur){
            if(!usedStatus.contains(s)){
                size++;
            }
        }
        return size;
    }

    /**
     a+
     */
    private List<Status> one2MultiNode(ASTree tree, int i){
        Set<Status> statuses = new HashSet<>();
        Set<Status> lastStatus = new HashSet<>();
        Status init = new Status(i);
        lastStatus.add(init);
        Set<Status> used = new HashSet<>();
        ASTree childNode = tree.getTreeList().get(0);
        int j=0;
        while (j < Integer.MAX_VALUE){
            statuses.addAll(lastStatus);
            Set<Status> curStatus = new HashSet<>();
            for(Status status : lastStatus){
                if(!used.contains(status)){
                    used.add(status);
                    List<Status> list = readASTree(childNode,status.getI());
                    curStatus.addAll(list);
                }
            }
            if(newStatusSize(used,curStatus) == 0){
                break;
            }
            lastStatus = curStatus;
            j++;
        }
        return new ArrayList<>(statuses);
    }

    /**
     * 处理范围类型的, 至少要出现rangeStart次， 之外的的就无所谓了
     */
    private List<Status> rangeNode(ASTree tree, int i){


        int rangeStart = tree.getRangeStart();
        int rangeEnd = tree.getRangeEnd();
        /**
         * 上一次状态
         */
        Set<Status> lastStatus = new HashSet<>();
        Status init = new Status(i);
        lastStatus.add(init);
        ASTree childNode = tree.getTreeList().get(0);
        for(int j=0;j<rangeStart;j++){
            Set<Status> curStatus = new HashSet<>();
            for(Status s : lastStatus){
                List<Status> list = readASTree(childNode,s.getI());
                /**
                 * 如果没有产生状态立马结束
                 */
                if(list.size() == 0){
                    return new ArrayList<>();
                }
                curStatus.addAll(list);
            }
            lastStatus = curStatus;
        }
        //存储前rangeStart次的最终状态存起来
        Set<Status> statuses = new HashSet<>(lastStatus);
        Set<Status> used = new HashSet<>();
        //处理 rangeStart->rangeEnd
        int j= rangeStart;
        while(j < rangeEnd){
            Set<Status> curStatus = new HashSet<>();
            for(Status s : lastStatus){
                if(!used.contains(s)){
                    used.add(s);
                    List<Status> list = readASTree(childNode,s.getI());
                    curStatus.addAll(list);
                }
            }
            if(newStatusSize(used,curStatus) == 0){
                break;
            }
            lastStatus = curStatus;
            /**
             * 将每一次迭代的结果存起来
             */
            statuses.addAll(lastStatus);
            j++;
        }
        return new ArrayList<>(statuses);
    }

    /**
     * 处理固定数量的,
     * 固定数量不用担心出现死循环， 因此不需要 一个Set来缓存已经处理的集合
     */
    private List<Status> fixedNode(ASTree tree, int i){
        int N = tree.getFixed();
        /**
         * 上一次状态
         */
        Set<Status> lastStatus = new HashSet<>();
        Status init = new Status(i);
        lastStatus.add(init);
        ASTree childNode = tree.getTreeList().get(0);
        for(int j=0;j<N;j++){
            Set<Status> curStatus = new HashSet<>();
            for(Status s : lastStatus){
                List<Status> list = readASTree(childNode,s.getI());
                curStatus.addAll(list);
            }
            if(curStatus.size() == 0){
                return new ArrayList<>();
            }
            lastStatus = curStatus;
        }

        return new ArrayList<>(lastStatus);
    }
    private List<Status> terminatorNode(ASTree tree, int i){
        List<Status> statuses = new ArrayList<>();
        if(i < str.length() && tree.getTerminate().terminate(str.charAt(i))){
            statuses.add(new Status(i+1));
        }
        return statuses;
    }
    private List<Status> endNode(int i){
        List<Status> statuses = new ArrayList<>();
        if(i == str.length()){
            statuses.add(new Status(i));
        }
        return statuses;
    }

    private List<Status> search(int fixed, int rangeStart,int rangeEnd,ASTree childNode,int i){

        Set<Status> lastStatus = new HashSet<>();
        Status init = new Status(i);
        Set<Status> used = new HashSet<>();
        lastStatus.add(init);
        for(int j=0;j<fixed;j++){
            Set<Status> curStatus = new HashSet<>();
            for(Status s : lastStatus){
                List<Status> list = readASTree(childNode,s.getI());
                curStatus.addAll(list);
            }
            if(curStatus.size() == 0){
                return new ArrayList<>();
            }
            lastStatus = curStatus;
        }
        //存储前rangeStart次的最终状态存起来
        Set<Status> statuses = new HashSet<>(lastStatus);
        //重置 used
        used = new HashSet<>();
        int j= rangeStart;
        while(j < rangeEnd){
            if(j == 0){
                j++;
                continue;
            }
            Set<Status> curStatus = new HashSet<>();
            for(Status s : lastStatus){
                if(!used.contains(s)){
                    used.add(s);
                    List<Status> list = readASTree(childNode,s.getI());
                    curStatus.addAll(list);
                }
            }
            if(newStatusSize(used,curStatus) == 0){
                break;
            }
            lastStatus = curStatus;
            statuses.addAll(lastStatus);
            j++;
        }
        return new ArrayList<>(statuses);

    }
}